class MD5
{
	public:
		static var _message = null;
		
		static function digest(message)
		{
			_message = message;
			# Step 1:
			var padded_bits = add_padding_bits();
			# Step 2:
			var preprocessed_message = append_length(padded_bits);
			# Step 3 & 4:
        	var processed_message = process_message(preprocessed_message);
		}
		
		static function add_padding_bits()
		{
			# Convert the message to a bit sequence
			var message_bytes = encode();
			
			# Append '1' as per MD5 padding requirements
			message_bytes.push(128);
			
			# Add '0's needed to pad the message
			while (message_bytes.size() * 8) % 512 != 448 do
			{
            	message_bytes.push(0);
			}
			
			return message_bytes;
		}
		
		static function encode()
		{
			var utf8 = [];
			for var i in 0:_message.size() do
			{ utf8.push(_message[i]); }
			return utf8;
		}
		
		static function append_length(padded_message)
		{
			var original_size = _message.size() * 8;
			var size_64bits = to_bytes(original_size);
			var preprocessed_message = padded_message.concat(size_64bits);
			return preprocessed_message;
		}
		
		static function to_bytes(number)
		{
			var byte_list = [];
			var temp_number = number;
			for var i in 0:4 do
			{
				var byte = number % 256;
				byte_list.push(byte);
        		temp_number = temp_number // 256;
			}
			return byte_list.concat([0, 0, 0, 0]);
		}
		
		static function initialize_md_buffer()
		{
        	var A = 1732584193;
        	var B = -271733879;
        	var C = -1732584194;
        	var D = 271733878;

        	return [A, B, C, D];
		}
		
		static function process_message(preprocessed_message)
		{
			var F = function(x, y, z) { return (x and y) or ((not x) and z); };
        	var G = function(x, y, z) { return (x and z) or (y and (not z)); };
        	var H = function(x, y, z) { return x xor y xor z; };
        	var I = function(x, y, z) { return y xor (x or (not z)); };
        	
        	
		}
}

